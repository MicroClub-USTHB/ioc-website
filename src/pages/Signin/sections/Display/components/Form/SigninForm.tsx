import React from 'react';
import * as yup from 'yup'; 
import { 
  Formik,
  Form,
  FormikHelpers,
} from 'formik';
import { api, useSignInMutation } from '../../../../../../redux/api/backend';
import FormControl from '../../../../../../common/Formik/FormControl';
import ErrorDisplay from '../../../../../../common/Formik/ErrorDisplay/ErrorDisplay';
import { useDispatch } from 'react-redux';
import { useHistory } from 'react-router-dom';

// styles
import formStyle from './SigninForm.module.scss';

// types
import { SignInResponse, SignInValues } from '../../../../../../types/User';
import { ValidationError } from '../../../../../../types/http';

const SigninForm = () => {
  const history = useHistory();
  const dispatch = useDispatch();
  const [ signIn ] = useSignInMutation();
  const initial_values: SignInValues = {
    email: '',
    password: '',
  }

  const validation_schema = new yup.ObjectSchema({
    email: yup.string().email("Must be a valid email.").required('This field is required.'),
    password: yup.string().min(8, 'Password must be at least 8 characters long.').required()
  })

  const handleSubmit = async (values: SignInValues, formikHelpers: FormikHelpers<SignInValues>) => {
    try {
      const res = await signIn(values);
      if (res.hasOwnProperty('data')) {
        const res_data_user = (res as { data: SignInResponse }).data.user;
        dispatch( api.util.updateQueryData('getUserData', null, state => { state = res_data_user; }) );
        history.push('/challenges');
      } else if (res.hasOwnProperty('error')) {
        const { error: error_res } = res as { error: unknown };
        // if error data contains an array then it's a validation error, the back-end sends validation errors in an array
        // I don't know what form of error the server might send so I'm doing very strict type guarding
        if ( typeof error_res === 'object' && (error_res ?? {}).hasOwnProperty('data') && Array.isArray((error_res as { data: unknown }).data!) && (error_res as {data: Array<ValidationError>}).data!.length > 0 ) {
          // if it reaches this point then received error is most likely a validation error generated by express-validator
          const first_error: ValidationError = (error_res as {data: Array<ValidationError>}).data[0];
          throw new Error(first_error.msg);
        } else {
          throw new Error('An unexpected error occured, please try again.');
        }
      }
    } catch (err) {
      // needs error handling logic
    }
  }
  return (
    <Formik
      initialValues={initial_values}
      validationSchema={validation_schema}
      onSubmit={handleSubmit}
    >
      {
        (props) => {
          const { values, errors, touched } = props;
          return (
            <Form>
              <ul className={formStyle.input_list}>
                <li>
                  <FormControl
                    control="email"
                    name="email"
                    label="Email"
                    label_className={`${formStyle.label} ${(errors.email && touched.email) && formStyle.error_color} ${values.email && formStyle.label_values}`}
                    field_className={formStyle.field}
                    error_className={formStyle.error}
                    ErrorComponent={ErrorDisplay}
                  />
                </li>
                <li>
                  <FormControl
                    control="password"
                    name="password"
                    label="Password"
                    label_className={`${formStyle.label} ${(errors.password && touched.password) && formStyle.error_color} ${values.password && formStyle.label_values}`}
                    field_className={formStyle.field}
                    error_className={formStyle.error}
                    ErrorComponent={ErrorDisplay}
                  />
                </li>
                <li>
                  <button className={formStyle.submit_button}>Sign In</button>
                </li>
              </ul>
            </Form>
          )
        }
      } 
    </Formik>
  );
}

export default SigninForm;
